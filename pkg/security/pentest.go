package security

import (
	"time"
)

// PenetrationTestHelper provides utilities for penetration testing
type PenetrationTestHelper struct {
	scanner   *SecurityScanner
	validator *InputValidator
}

// NewPenetrationTestHelper creates a new penetration test helper
func NewPenetrationTestHelper() *PenetrationTestHelper {
	return &PenetrationTestHelper{
		scanner:   NewSecurityScanner(),
		validator: NewInputValidator(),
	}
}

// GetScanner returns the security scanner
func (p *PenetrationTestHelper) GetScanner() *SecurityScanner {
	return p.scanner
}

// InjectionPayloads returns common injection attack payloads
func (p *PenetrationTestHelper) InjectionPayloads() []string {
	return []string{
		"' OR '1'='1",
		"' OR '1'='1' --",
		"'; DROP TABLE users--",
		"admin'--",
		"1' UNION SELECT NULL--",
		"1' AND '1'='1",
		"' OR 1=1--",
		"1'; EXEC sp_MSForEachTable 'DROP TABLE ?'--",
	}
}

// XSSPayloads returns common XSS attack payloads
func (p *PenetrationTestHelper) XSSPayloads() []string {
	return []string{
		"<script>alert('XSS')</script>",
		"<img src=x onerror=alert('XSS')>",
		"<iframe src='javascript:alert(\"XSS\")'></iframe>",
		"<body onload=alert('XSS')>",
		"javascript:alert('XSS')",
		"<svg/onload=alert('XSS')>",
		"<input onfocus=alert('XSS') autofocus>",
	}
}

// PathTraversalPayloads returns common path traversal payloads
func (p *PenetrationTestHelper) PathTraversalPayloads() []string {
	return []string{
		"../../etc/passwd",
		"..\\..\\windows\\system32\\config\\sam",
		"....//....//etc/passwd",
		"..%2F..%2Fetc%2Fpasswd",
		"..%252F..%252Fetc%252Fpasswd",
		"..;/..;/etc/passwd",
	}
}

// TestInjection tests for injection vulnerabilities
func (p *PenetrationTestHelper) TestInjection(testFunc func(string) error) []string {
	var failures []string

	for _, payload := range p.InjectionPayloads() {
		err := testFunc(payload)
		if err == nil {
			failures = append(failures, payload)
		}
	}

	return failures
}

// TestXSS tests for XSS vulnerabilities
func (p *PenetrationTestHelper) TestXSS(testFunc func(string) error) []string {
	var failures []string

	for _, payload := range p.XSSPayloads() {
		err := testFunc(payload)
		if err == nil {
			failures = append(failures, payload)
		}
	}

	return failures
}

// TestPathTraversal tests for path traversal vulnerabilities
func (p *PenetrationTestHelper) TestPathTraversal(testFunc func(string) error) []string {
	var failures []string

	for _, payload := range p.PathTraversalPayloads() {
		err := testFunc(payload)
		if err == nil {
			failures = append(failures, payload)
		}
	}

	return failures
}

// RateLimitTester tests rate limiting
type RateLimitTester struct {
	requests []time.Time
}

// NewRateLimitTester creates a new rate limit tester
func NewRateLimitTester() *RateLimitTester {
	return &RateLimitTester{
		requests: make([]time.Time, 0),
	}
}

// TestRateLimit tests if rate limiting is enforced
func (r *RateLimitTester) TestRateLimit(testFunc func() error, count int, duration time.Duration) (bool, int) {
	start := time.Now()
	successCount := 0

	for i := 0; i < count; i++ {
		if time.Since(start) > duration {
			break
		}

		err := testFunc()
		if err == nil {
			successCount++
		} else {
			// Rate limit likely triggered
			return true, successCount
		}
	}

	// If all requests succeeded, rate limiting may not be working
	return false, successCount
}
